package com.tpinf4067.sale_vehicle.service;

import com.tpinf4067.sale_vehicle.patterns.payment.*;
import com.tpinf4067.sale_vehicle.patterns.payment.template.TaxTemplate;
import com.tpinf4067.sale_vehicle.patterns.payment.template.TaxTemplateFactory;
import com.tpinf4067.sale_vehicle.repository.DocumentRepository;
import com.tpinf4067.sale_vehicle.repository.OrderRepository;
import com.tpinf4067.sale_vehicle.repository.PaymentRepository;
import com.tpinf4067.sale_vehicle.patterns.document.*;
import com.tpinf4067.sale_vehicle.patterns.order.factory.Order;
import com.tpinf4067.sale_vehicle.patterns.auth.User;

import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class PaymentService {

    private final PaymentRepository paymentRepository;
    private final OrderRepository orderRepository;
    private final DocumentRepository documentRepository;  // ‚úÖ Ajout du repository des documents
    private final PDFDocumentAdapter pdfAdapter;
    private final OrderService orderService;

    public PaymentService(PaymentRepository paymentRepository, OrderRepository orderRepository, DocumentRepository documentRepository, OrderService orderService) {
        this.paymentRepository = paymentRepository;
        this.orderRepository = orderRepository;
        this.documentRepository = documentRepository;
        this.orderService = orderService;
        this.pdfAdapter = new PDFDocumentAdapter();
    }

    // ‚úÖ üî• Nouvelle m√©thode pour r√©cup√©rer la derni√®re commande non pay√©e
    private Order getLastUnpaidOrder(Long customerId) {
        return orderRepository.findByCustomerId(customerId)
                .stream()
                .filter(order -> !paymentRepository.existsByOrderAndStatus(order, PaymentStatus.PAYE))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("‚ùå Aucune commande en attente de paiement."));
    }

    // ‚úÖ Modifier la m√©thode `processPayment` pour ne plus exiger `orderId`
    public Payment processPayment(User user, PaymentType paymentType, String country) {
        if (user.getCustomer() == null) {
            throw new IllegalStateException("‚ùå Impossible de traiter le paiement. Aucun client associ√©.");
        }

        // üî• R√©cup√©rer la derni√®re commande en attente de paiement
        Order order = getLastUnpaidOrder(user.getCustomer().getId());

        // üî• Utilisation du Pattern Strategy pour le calcul des taxes
        TaxTemplate taxStrategy = TaxTemplateFactory.getTaxStrategy(country);
        double taxes = taxStrategy.calculateTax(order.getTotalPrice());
        double totalAmount = order.getTotalPrice() + taxes;

        // üî• Cr√©ation du paiement
        Payment payment = new Payment(order, paymentType, country, order.getTotalPrice(), taxes, totalAmount);
        paymentRepository.save(payment);

        System.out.println("üí≥ Paiement cr√©√© pour la commande #" + order.getId() + " | Montant total : " + payment.getTotalAmount() + " FCFA");

        return payment;
    }

    // ‚úÖ Modifier la confirmation de paiement pour ne plus exiger `paymentId`
    public Payment confirmPayment(User user) {
        if (user.getCustomer() == null) {
            throw new IllegalStateException("‚ùå Aucun client associ√© √† cet utilisateur.");
        }
    
        // üî• R√©cup√©rer le dernier paiement en attente
        Payment payment = paymentRepository.findByOrder_CustomerId(user.getCustomer().getId())
                .stream()
                .filter(p -> !p.isPaid())
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("‚ùå Aucun paiement en attente de confirmation."));
    
        // üî• V√©rification et confirmation
        if (payment.isPaid()) {
            throw new IllegalStateException("Le paiement a d√©j√† √©t√© valid√© !");
        }
    
        payment.confirmPayment();
        paymentRepository.save(payment);
        paymentRepository.flush(); // üî• Forcer l'enregistrement imm√©diat en BD
    
        // üî• G√©n√©ration de la facture apr√®s confirmation
        generateInvoice(payment);

        // ‚úÖ Mettre √† jour l'√©tat de la commande apr√®s confirmation du paiement
        Order order = payment.getOrder();
        if (!"LIVREE".equals(order.getState().getStatus())) {
            orderService.changeOrderStatus(order.getId(), true); // üî• Passer la commande √† "LIVREE"
        }
    
        System.out.println("‚úÖ Paiement confirm√© pour la commande #" + payment.getOrder().getId());
        return payment;
    }
    

    // ‚úÖ Rejet d‚Äôun paiement sans paymentId (r√©cup√©ration automatique du dernier paiement en attente)
    public Payment rejectPayment(User user) {
        Payment payment = paymentRepository.findFirstByOrderCustomerIdAndStatus(user.getCustomer().getId(), PaymentStatus.EN_ATTENTE)
                .orElseThrow(() -> new IllegalArgumentException("Aucun paiement en attente trouv√© pour ce client !"));
    
        payment.rejectPayment();
        paymentRepository.save(payment);
    
        System.out.println("‚ùå Paiement rejet√© pour la commande #" + payment.getOrder().getId());
        return payment;
    }

    // ‚úÖ G√©n√©ration de la facture PDF apr√®s validation du paiement avec un nom unique
    // ‚úÖ G√©n√©ration et enregistrement de la facture apr√®s confirmation du paiement
    // ‚úÖ G√©n√©ration et enregistrement de la facture apr√®s confirmation du paiement
    private void generateInvoice(Payment payment) {
        Order order = payment.getOrder();

        // ‚úÖ G√©n√©ration d'un nom unique pour la facture li√©e √† la commande
        String fileName = "Facture_de_Paiement_-_Commande_#" + order.getId() + ".pdf";

        // ‚úÖ Construction de la facture
        Document invoice = new Document();
        invoice.setTitle("Facture de Paiement - Commande #" + order.getId());
        invoice.setFilename(fileName); // ‚úÖ Utilisation du nom unique
        invoice.setContent("<p><strong>Commande #" + order.getId() + "</strong></p>" +
                        "<p><strong>Client :</strong> " + order.getCustomer().getName() + "</p>" +
                        "<p><strong>Pays :</strong> " + payment.getCountry() + "</p>" +
                        "<p><strong>Montant HT :</strong> " + payment.getAmount() + " FCFA</p>" +
                        "<p><strong>Taxes :</strong> " + payment.getTaxes() + " FCFA</p>" +
                        "<p><strong>Total TTC :</strong> " + payment.getTotalAmount() + " FCFA</p>");

        // ‚úÖ Enregistrer la facture en base de donn√©es
        invoice.setPayment(payment); // Associer la facture au paiement
        documentRepository.save(invoice); // Sauvegarde dans la BD

        // ‚úÖ Export en PDF
        pdfAdapter.export(invoice);

        System.out.println("üìÑ Facture enregistr√©e en BD et g√©n√©r√©e sous le nom : " + fileName);
    }



    // ‚úÖ R√©cup√©rer toutes les factures pour ADMIN
   public List<PaymentInvoiceDTO> getAllInvoices() {
        List<Document> invoices = documentRepository.findAll();
        return invoices.stream().map(doc -> new PaymentInvoiceDTO(
            doc.getId(),
            doc.getTitle(),
            doc.getFilename(),
            doc.getContent(),
            doc.getOrder() != null ? doc.getOrder().getId() : null,
            doc.getPayment() != null ? doc.getPayment().getId() : null
        )).collect(Collectors.toList());
    }


    // ‚úÖ R√©cup√©rer uniquement les factures d‚Äôun utilisateur
    public List<Document> getUserInvoices(User user) {
        return documentRepository.findByPayment_Order_CustomerId(user.getCustomer().getId());
    }
    

    // ‚úÖ R√©cup√©rer une facture sp√©cifique par ID
    public Document getInvoiceById(Long id) {
        return documentRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("‚ùå Facture introuvable avec ID : " + id));
    }
}
